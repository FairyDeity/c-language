#include <stdio.h>
//第一个字节内容不为零则是小端
/*int main()
{
	int a=1;

	char* p = (char*)&a;//char 型正好可以取出一个字节
	if(*p==1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}
	return 0;
}
//2.用函数形式
//返回1，小端
//返回0，大端
int check_sys()
{
	int a=1;
	char*p=(char*)&a;//可直接写成 return *（char*）&a；
	/*if(*p==1)
		return 1;
	else
		return 0;
	return *p;//返回1，小端；返回0，大端
}*/
/*int main()
{
	int ret=check_sys();
	if(ret==1)
		{ 
			printf("小端\n");

		}
	else
	{
		printf("大端\n");
	}
return 0;
}*/
//练习1.原码反码补码
/*int main()
{
	char a=-1;
	//原码:10000000 00000000 00000000 00000001
	//反码:11111111 11111111 11111111 11111110
	//补码:11111111 11111111 11111111 11111111
	//a只能存八个bite位：11111111
	//整型提升，按着原符号位提升，高位为符号位则为11111111 11111111 11111111 11111111，此时为补码，我们再看原码，则打印出来为 -1
	signed char b= -1;
	//11111111
	//与第一个打印相同
	unsigned char c= -1;
	//11111111
	//unsigned 第一位不是符号位，则我们要补0为：00000000 00000000 00000000 11111111
	//高位是0为正数，原码，反码，补码相同，所以原码也是这样。转化为十进制为255
	printf("a=%d,b=%d,c=%d",a,b,c);
	       //-1   -1   255
	return 0;
}*/
/*int main()
{

	char a= -128;
	//100000000000000000000001000000
	//111111111111111111111110111111
	//111111111111111111111111000000
	// a存八位:10000000
	//整型提升看的是char类型，高位是符号位则补1为：
	//11111111 11111111 11111111 10000000，仍旧是补码，因为是打印%u是无符号数字，则补码和原码相同。
	printf("%u\n",a);//打印十进制无符号数字
	//4294967168
	return 0;
}*/
/*
int main ()
{
char a[1000]
int i;
for(i=0;i<1000;i++)
{
 a[i]=-1-i;

}
printf("%d",strlen(a));
return 0;
}
打印出的是255，char类型范围是-127~128
*/